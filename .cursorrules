# Coding Rules

## Core Principles

### 1. Minimal Code Approach
- Write only the **minimum code necessary** to achieve functionality
- Remove all defensive programming and validation unless absolutely critical
- Fail fast - let errors bubble up naturally instead of catching and wrapping them
- No unnecessary abstractions or layers

### 2. Comments Policy
- **No "what" comments** - the code should be self-explanatory
- **Minimal "why" comments** - only when reading the code alone is insufficient to understand the reasoning
- Prefer clear variable/function names over comments
- If you need many comments, the code is probably too complex

### 3. Error Handling
- Don't wrap every operation in try/catch
- Let exceptions propagate unless you have a specific recovery strategy
- Prefer `raise` over returning error objects when possible
- Only handle errors at the appropriate boundary level

### 4. Code Structure
- Direct execution over complex validation
- Simple conditionals over elaborate state machines
- Explicit over implicit behavior
- One responsibility per function/class

### 5. Examples

**Bad (defensive):**
```python
def process_data(data):
    if not data:
        return {"error": "No data provided", "success": False}
    try:
        result = complex_validation(data)
        if not result.is_valid():
            return {"error": "Validation failed", "success": False}
        processed = expensive_operation(result)
        return {"data": processed, "success": True}
    except Exception as e:
        return {"error": f"Processing failed: {e}", "success": False}
```

**Good (minimal):**
```python
def process_data(data):
    validated = validate(data)  # Raises if invalid
    return expensive_operation(validated)
```

### 6. When to Add Comments
- Complex business logic that isn't obvious
- Performance optimizations with non-obvious reasoning
- Workarounds for external system quirks
- Regulatory or compliance requirements

### 7. When NOT to Add Comments
- Explaining what a variable stores
- Describing obvious operations
- Documenting API signatures (use type hints instead)
- Explaining basic programming concepts

### 8. Object-Oriented Design
- **Single Responsibility**: Each class should have one clear purpose
- **Composition over Inheritance**: Prefer composition and delegation
- **Separation of Concerns**: Extract complex logic into separate classes/files
- **Avoid Over-Engineering**: Don't create methods with single-line implementations

### 9. Refactoring Guidelines
- **Extract when complex**: Move complex logic to separate classes
- **Keep it simple**: Prefer direct code over unnecessary abstractions
- **Organize by responsibility**: Separate files for different concerns
- **Test the refactor**: Ensure functionality remains the same

### 10. Git and Commits
- **NEVER suggest commits** unless explicitly asked
- Only commit when user explicitly requests it
- Don't propose commit messages or git operations
- Focus on code changes, not version control workflow
